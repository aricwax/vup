#!/usr/bin/env python3
"""vup-core - Python backend for vup virtual environment manager."""

import argparse
import subprocess
import sys
import os
from pathlib import Path

HOME = Path.home()


def is_within_home(path: Path) -> bool:
    """Check if path is within the user's home directory."""
    try:
        path.resolve().relative_to(HOME)
        return True
    except ValueError:
        return False


def validate_venv(path: Path) -> int:
    """Validate a venv path.

    Returns:
        0: valid venv
        1: path not found
        2: path is not a directory
        3: missing bin/activate
    """
    if not path.exists():
        return 1
    if not path.is_dir():
        return 2
    if not (path / 'bin' / 'activate').exists():
        return 3
    return 0


def cmd_find(args):
    """Find a venv by name, searching upward from start directory."""
    name = args.name

    # Determine start directory
    if args.start_dir:
        start = Path(args.start_dir).expanduser().resolve()
        if not is_within_home(start):
            print(f"Error: '{args.start_dir}' is not within home directory", file=sys.stderr)
            return 1
        if not start.is_dir():
            print(f"Error: '{args.start_dir}' is not a directory", file=sys.stderr)
            return 1
    else:
        start = Path.cwd()

    # If outside home (and no explicit start-dir), fallback to ~/.venv/
    if not is_within_home(start):
        venv_path = HOME / '.venv' / name
        status = validate_venv(venv_path)
        if status == 0:
            print(venv_path)
            return 0
        elif status == 1:
            print(f"Error: venv '{name}' not found in ~/.venv/", file=sys.stderr)
        elif status == 2:
            print(f"Error: ~/.venv/{name} is not a directory", file=sys.stderr)
        elif status == 3:
            print(f"Error: ~/.venv/{name} is not a valid venv (missing bin/activate)", file=sys.stderr)
        return 1

    # Search upward from start to HOME
    current = start.resolve()
    while True:
        venv_dir = current / '.venv'
        venv_path = venv_dir / name

        # Check .venv exists
        if venv_dir.exists():
            if not venv_dir.is_dir():
                print(f"Warning: {venv_dir} exists but is not a directory", file=sys.stderr)
            elif venv_path.exists():
                if not venv_path.is_dir():
                    print(f"Warning: {venv_path} exists but is not a directory", file=sys.stderr)
                elif not (venv_path / 'bin' / 'activate').exists():
                    print(f"Warning: {venv_path} is not a valid venv (missing bin/activate)", file=sys.stderr)
                else:
                    # Found valid venv
                    print(venv_path)
                    return 0

        # Stop conditions
        if args.no_traverse or current == HOME:
            break
        current = current.parent

    # Not found
    if args.no_traverse:
        print(f"Error: venv '{name}' not found in {start}/.venv/", file=sys.stderr)
    else:
        print(f"Error: venv '{name}' not found", file=sys.stderr)
    return 1


def cmd_ls(args):
    """List all discoverable venvs."""
    # Determine start directory
    if args.start_dir:
        start = Path(args.start_dir).expanduser().resolve()
        if not is_within_home(start):
            print(f"Error: '{args.start_dir}' is not within home directory", file=sys.stderr)
            return 1
        if not start.is_dir():
            print(f"Error: '{args.start_dir}' is not a directory", file=sys.stderr)
            return 1
    else:
        start = Path.cwd()

    # Get active venv path for comparison
    active_venv = os.environ.get('VIRTUAL_ENV')
    if active_venv:
        active_venv = Path(active_venv).resolve()

    # Collect all venvs: list of (name, branch_dir, full_path)
    venvs = []

    if not is_within_home(start):
        # Outside home: only list ~/.venv/
        dirs_to_check = [HOME]
    else:
        # Within home: traverse from start to HOME
        dirs_to_check = []
        current = start.resolve()
        while True:
            dirs_to_check.append(current)
            if current == HOME:
                break
            current = current.parent

    for dir_path in dirs_to_check:
        venv_dir = dir_path / '.venv'
        if venv_dir.is_dir():
            for entry in sorted(venv_dir.iterdir()):
                if entry.is_dir() and (entry / 'bin' / 'activate').exists():
                    venvs.append((entry.name, dir_path, entry.resolve()))

    if not venvs:
        return 0

    # Format output with aligned columns
    max_name_len = max(len(v[0]) for v in venvs)

    for name, branch_dir, full_path in venvs:
        # Active indicator
        if active_venv and full_path == active_venv:
            indicator = '*'
        else:
            indicator = ' '

        # Format branch dir for display
        if branch_dir == HOME:
            branch_display = '~'
        else:
            try:
                branch_display = '~/' + str(branch_dir.relative_to(HOME))
            except ValueError:
                branch_display = str(branch_dir)

        print(f"{indicator} {name:<{max_name_len}}  {branch_display}")

    return 0


def cmd_validate(args):
    """Validate a venv path."""
    path = Path(args.path)
    result = validate_venv(path)

    if result == 1:
        print(f"Error: '{path}' not found", file=sys.stderr)
    elif result == 2:
        print(f"Error: '{path}' is not a directory", file=sys.stderr)
    elif result == 3:
        print(f"Error: '{path}' is not a valid venv (missing bin/activate)", file=sys.stderr)

    return result


def cmd_init(args):
    """Initialize .venv/ directory."""
    cwd = Path.cwd()
    target = cwd if is_within_home(cwd) else HOME
    venv_dir = target / '.venv'

    if venv_dir.exists():
        print(f"Error: .venv already exists in {target}", file=sys.stderr)
        print("Use 'vup new <name>' to create a new venv.", file=sys.stderr)
        return 1

    venv_dir.mkdir()
    return 0


def cmd_new(args):
    """Create a new venv."""
    cwd = Path.cwd()
    in_home = is_within_home(cwd)
    target = cwd if in_home else HOME
    venv_dir = target / '.venv'
    venv_path = venv_dir / args.name

    # Check .venv/ exists (different behavior in/out of home)
    if not venv_dir.exists():
        if in_home:
            print(f"Error: .venv/ does not exist in {target}", file=sys.stderr)
            print("Use 'vup init' first to initialize.", file=sys.stderr)
            return 1
        else:
            # Auto-create ~/.venv/ when outside home
            venv_dir.mkdir()

    # Check if venv already exists
    if venv_path.exists():
        print(f"Error: venv '{args.name}' already exists in {venv_dir}", file=sys.stderr)
        return 1

    # Create the venv
    result = subprocess.run(
        [sys.executable, '-m', 'venv', str(venv_path)],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"Error creating venv: {result.stderr}", file=sys.stderr)
        return 1

    # Output path for bash to activate
    print(venv_path)
    return 0


def cmd_prompt(args):
    """Generate prompt identifier from venv path."""
    venv_path = Path(args.venv_path).resolve()
    venv_name = venv_path.name
    branch_dir = venv_path.parent.parent  # parent of .venv/

    if branch_dir == HOME:
        branch_name = '~'
    else:
        branch_name = branch_dir.name

    print(f"{branch_name}/{venv_name}")
    return 0


def main():
    parser = argparse.ArgumentParser(
        prog='vup-core',
        description='Python backend for vup virtual environment manager'
    )
    subparsers = parser.add_subparsers(dest='command', required=True)

    # find <name> [--start-dir <dir>] [--no-traverse]
    p_find = subparsers.add_parser('find', help='Find a venv by name')
    p_find.add_argument('name', help='Name of the venv to find')
    p_find.add_argument('--start-dir', default=None, help='Directory to start search from')
    p_find.add_argument('--no-traverse', action='store_true', help='Disable upward directory traversal')
    p_find.set_defaults(func=cmd_find)

    # ls [--start-dir <dir>]
    p_ls = subparsers.add_parser('ls', help='List all discoverable venvs')
    p_ls.add_argument('--start-dir', default=None, help='Directory to start listing from')
    p_ls.set_defaults(func=cmd_ls)

    # validate <path>
    p_validate = subparsers.add_parser('validate', help='Validate a venv path')
    p_validate.add_argument('path', help='Path to validate')
    p_validate.set_defaults(func=cmd_validate)

    # init
    p_init = subparsers.add_parser('init', help='Initialize .venv/ directory')
    p_init.set_defaults(func=cmd_init)

    # new <name>
    p_new = subparsers.add_parser('new', help='Create a new venv')
    p_new.add_argument('name', help='Name of the venv to create')
    p_new.set_defaults(func=cmd_new)

    # prompt <venv-path>
    p_prompt = subparsers.add_parser('prompt', help='Generate prompt identifier')
    p_prompt.add_argument('venv_path', help='Full path to the venv')
    p_prompt.set_defaults(func=cmd_prompt)

    args = parser.parse_args()
    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
