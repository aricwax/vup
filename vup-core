#!/usr/bin/env python3
# vup-core - Python backend for vup virtual environment manager
#
# This script handles all complex logic for vup that doesn't require direct
# shell environment manipulation. It is called by the vup bash function
# (vup.bash) which handles shell-level operations like sourcing activate
# scripts and modifying PS1.
#
# Communication with bash:
#   stdout  - Output data (venv paths, formatted listings, prompt strings)
#   stderr  - Error and warning messages
#   exit    - 0 for success, non-zero for failure
#
# Subcommands:
#   find <name> [--start-dir <dir>] [--no-traverse]
#       Search for a venv by name, starting from cwd (or --start-dir) and
#       traversing up to ~. Outputs full path on success.
#
#   ls [--start-dir <dir>]
#       List all discoverable venvs from cwd (or --start-dir) up to ~.
#       Outputs formatted, aligned table with active indicator.
#
#   validate <path>
#       Check if a path is a valid venv. Exit codes: 0=valid, 1=not found,
#       2=not a directory, 3=missing bin/activate.
#
#   init
#       Create .venv/ directory in cwd (or ~ if outside home).
#
#   new <name>
#       Create a new venv. Outputs full path for bash to activate.
#
#   prompt <venv-path>
#       Generate prompt identifier (e.g., "foo/main" or "~/main").
#
#   help
#       Display user-facing help message.
#
# Testing:
#   All subcommands are tested by test_vup_core.py via subprocess calls.
#
# Fallback behavior:
#   When cwd is outside ~, commands fall back to operating on ~/.venv/.
#
# See dev.md for full design documentation.

import argparse
import subprocess
import sys
import os
from pathlib import Path

HOME = Path.home()


# is_within_home(path)
# Check if a path is within the user's home directory.
#
# Args:
#   path: Path object to check
#
# Returns:
#   True if path is under ~, False otherwise
def is_within_home(path: Path) -> bool:
    try:
        # relative_to() raises ValueError if path is not under HOME
        path.resolve().relative_to(HOME)
        return True
    except ValueError:
        return False


# validate_venv(path)
# Check if a path is a valid Python virtual environment.
#
# A valid venv is a directory containing bin/activate.
#
# Args:
#   path: Path object to the venv directory
#
# Returns:
#   0: valid venv
#   1: path not found
#   2: path exists but is not a directory
#   3: directory exists but missing bin/activate
def validate_venv(path: Path) -> int:
    if not path.exists():
        return 1
    if not path.is_dir():
        return 2
    if not (path / 'bin' / 'activate').exists():
        return 3
    return 0


# cmd_find(args)
# Find a venv by name, searching upward from start directory to ~.
#
# Searches for .venv/<name>/ starting from cwd (or --start-dir) and traversing
# up the directory tree to ~. If --no-traverse is set, only checks the start
# directory. When outside ~, falls back to ~/.venv/<name>.
#
# Args:
#   args.name: Name of the venv to find
#   args.start_dir: Optional starting directory (default: cwd)
#   args.no_traverse: If True, don't traverse up the directory tree
#
# Output:
#   stdout: Full path to venv on success
#   stderr: Error/warning messages
#
# Returns:
#   0 on success, 1 on failure
def cmd_find(args):
    name = args.name

    # Determine start directory
    if args.start_dir:
        start = Path(args.start_dir).expanduser().resolve()
        if not is_within_home(start):
            print(f"Error: '{args.start_dir}' is not within home directory", file=sys.stderr)
            return 1
        if not start.is_dir():
            print(f"Error: '{args.start_dir}' is not a directory", file=sys.stderr)
            return 1
    else:
        start = Path.cwd()

    # If outside home (and no explicit start-dir), fallback to ~/.venv/
    if not is_within_home(start):
        venv_path = HOME / '.venv' / name
        status = validate_venv(venv_path)
        if status == 0:
            print(venv_path)
            return 0
        elif status == 1:
            print(f"Error: venv '{name}' not found in ~/.venv/", file=sys.stderr)
        elif status == 2:
            print(f"Error: ~/.venv/{name} is not a directory", file=sys.stderr)
        elif status == 3:
            print(f"Error: ~/.venv/{name} is not a valid venv (missing bin/activate)", file=sys.stderr)
        return 1

    # Search upward from start to HOME
    current = start.resolve()
    while True:
        venv_dir = current / '.venv'
        venv_path = venv_dir / name

        # Validate in stages: .venv/ -> .venv/<name>/ -> bin/activate
        # Emit warnings for invalid states but continue searching up the tree
        if venv_dir.exists():
            if not venv_dir.is_dir():
                print(f"Warning: {venv_dir} exists but is not a directory", file=sys.stderr)
            elif venv_path.exists():
                if not venv_path.is_dir():
                    print(f"Warning: {venv_path} exists but is not a directory", file=sys.stderr)
                elif not (venv_path / 'bin' / 'activate').exists():
                    print(f"Warning: {venv_path} is not a valid venv (missing bin/activate)", file=sys.stderr)
                else:
                    # Found valid venv
                    print(venv_path)
                    return 0

        # Stop conditions
        if args.no_traverse or current == HOME:
            break
        current = current.parent

    # Not found
    if args.no_traverse:
        print(f"Error: venv '{name}' not found in {start}/.venv/", file=sys.stderr)
    else:
        print(f"Error: venv '{name}' not found", file=sys.stderr)
    return 1


# cmd_ls(args)
# List all discoverable venvs from start directory up to ~.
#
# Traverses from cwd (or --start-dir) up to ~ and lists all valid venvs found
# in .venv/ directories along the way. When outside ~, only lists ~/.venv/.
# Output is formatted as an aligned table with an active indicator (*).
#
# Args:
#   args.start_dir: Optional starting directory (default: cwd)
#
# Output:
#   stdout: Formatted table with columns: active indicator, name, branch dir
#   stderr: Error messages
#
# Returns:
#   0 on success, 1 on failure
#
# Environment:
#   VIRTUAL_ENV: Used to determine which venv is currently active
def cmd_ls(args):
    # Determine start directory
    if args.start_dir:
        start = Path(args.start_dir).expanduser().resolve()
        if not is_within_home(start):
            print(f"Error: '{args.start_dir}' is not within home directory", file=sys.stderr)
            return 1
        if not start.is_dir():
            print(f"Error: '{args.start_dir}' is not a directory", file=sys.stderr)
            return 1
    else:
        start = Path.cwd()

    # Get active venv path for comparison
    active_venv = os.environ.get('VIRTUAL_ENV')
    if active_venv:
        active_venv = Path(active_venv).resolve()

    # Collect all venvs: list of (name, branch_dir, full_path)
    venvs = []

    if not is_within_home(start):
        # Outside home: only list ~/.venv/
        dirs_to_check = [HOME]
    else:
        # Within home: traverse from start to HOME
        dirs_to_check = []
        current = start.resolve()
        while True:
            dirs_to_check.append(current)
            if current == HOME:
                break
            current = current.parent

    # Scan each directory's .venv/ for valid venvs
    for dir_path in dirs_to_check:
        venv_dir = dir_path / '.venv'
        if venv_dir.is_dir():
            for entry in sorted(venv_dir.iterdir()):
                # Only include directories with bin/activate (valid venvs)
                if entry.is_dir() and (entry / 'bin' / 'activate').exists():
                    venvs.append((entry.name, dir_path, entry.resolve()))

    if not venvs:
        return 0

    # Format output with aligned columns
    max_name_len = max(len(v[0]) for v in venvs)

    for name, branch_dir, full_path in venvs:
        # Active indicator
        if active_venv and full_path == active_venv:
            indicator = '*'
        else:
            indicator = ' '

        # Format branch dir for display (~ for home, ~/path for subdirs)
        if branch_dir == HOME:
            branch_display = '~'
        else:
            try:
                branch_display = '~/' + str(branch_dir.relative_to(HOME))
            except ValueError:
                # Fallback for edge cases where path isn't under HOME
                branch_display = str(branch_dir)

        print(f"{indicator} {name:<{max_name_len}}  {branch_display}")

    return 0


# cmd_validate(args)
# Validate a venv path and print error message if invalid.
#
# Wrapper around validate_venv() that outputs human-readable error messages.
# Used by vup.bash to check venvs before operations like rm.
#
# Args:
#   args.path: Path to the venv directory to validate
#
# Output:
#   stdout: (empty)
#   stderr: Error message if invalid
#
# Returns:
#   0: valid venv
#   1: path not found
#   2: path is not a directory
#   3: missing bin/activate
def cmd_validate(args):
    path = Path(args.path)
    result = validate_venv(path)

    if result == 1:
        print(f"Error: '{path}' not found", file=sys.stderr)
    elif result == 2:
        print(f"Error: '{path}' is not a directory", file=sys.stderr)
    elif result == 3:
        print(f"Error: '{path}' is not a valid venv (missing bin/activate)", file=sys.stderr)

    return result


# cmd_init(args)
# Create .venv/ directory in the current directory (or ~ if outside home).
#
# Initializes a directory to hold venvs. Must be run before `vup new` when
# inside ~. When outside ~, creates ~/.venv/ instead.
#
# Args:
#   args: (no arguments used)
#
# Output:
#   stdout: (empty on success)
#   stderr: Error message if .venv already exists
#
# Returns:
#   0 on success, 1 if .venv already exists
def cmd_init(args):
    cwd = Path.cwd()
    target = cwd if is_within_home(cwd) else HOME
    venv_dir = target / '.venv'

    if venv_dir.exists():
        print(f"Error: .venv already exists in {target}", file=sys.stderr)
        print("Use 'vup new <name>' to create a new venv.", file=sys.stderr)
        return 1

    venv_dir.mkdir()
    return 0


# cmd_new(args)
# Create a new Python virtual environment.
#
# Creates a venv using `python3 -m venv`. When inside ~, requires .venv/ to
# exist (use `vup init` first). When outside ~, auto-creates ~/.venv/ if needed.
# Outputs the full path so vup.bash can activate it.
#
# Args:
#   args.name: Name for the new venv
#
# Output:
#   stdout: Full path to created venv (for bash to activate)
#   stderr: Error messages
#
# Returns:
#   0 on success, 1 on failure
def cmd_new(args):
    cwd = Path.cwd()
    in_home = is_within_home(cwd)
    target = cwd if in_home else HOME
    venv_dir = target / '.venv'
    venv_path = venv_dir / args.name

    # Check .venv/ exists (different behavior in/out of home)
    if not venv_dir.exists():
        if in_home:
            print(f"Error: .venv/ does not exist in {target}", file=sys.stderr)
            print("Use 'vup init' first to initialize.", file=sys.stderr)
            return 1
        else:
            # Auto-create ~/.venv/ when outside home
            venv_dir.mkdir()

    # Check if venv already exists
    if venv_path.exists():
        print(f"Error: venv '{args.name}' already exists in {venv_dir}", file=sys.stderr)
        return 1

    # Create the venv
    result = subprocess.run(
        [sys.executable, '-m', 'venv', str(venv_path)],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"Error creating venv: {result.stderr}", file=sys.stderr)
        return 1

    # Output path for bash to activate
    print(venv_path)
    return 0


# cmd_prompt(args)
# Generate a prompt identifier string from a venv path.
#
# Extracts the branch directory (parent of .venv/) and venv name to create
# a compact identifier for the shell prompt. Home directory is displayed as ~.
#
# Examples:
#   ~/.venv/main         -> ~/main
#   ~/proj/foo/.venv/dev -> foo/dev
#
# Args:
#   args.venv_path: Full path to the venv directory
#
# Output:
#   stdout: Prompt identifier string (e.g., "foo/main" or "~/main")
#
# Returns:
#   0 always
def cmd_prompt(args):
    venv_path = Path(args.venv_path).resolve()
    venv_name = venv_path.name
    # venv_path is like ~/proj/.venv/main, so parent.parent gets ~/proj (the branch dir)
    branch_dir = venv_path.parent.parent

    if branch_dir == HOME:
        branch_name = '~'
    else:
        branch_name = branch_dir.name

    print(f"{branch_name}/{venv_name}")
    return 0


# cmd_help(args)
# Display the user-facing help message.
#
# Shows usage information for all vup commands. This is the help text users
# see, not the internal argparse help.
#
# Args:
#   args: (no arguments used)
#
# Output:
#   stdout: Help text
#
# Returns:
#   0 always
def cmd_help(args):
    print("""vup - Python virtual environment manager

Usage:
  vup <name>           Activate venv (searches upward from cwd to ~)
  vup -d <dir> <name>  Activate venv from specific directory (no traversal)
  vup ls [dir]         List discoverable venvs
  vup init             Create .venv/ directory in cwd
  vup new <name>       Create and activate a new venv
  vup rm <name>        Remove a venv (must be in branch directory)
  vup off              Deactivate current venv
  vup help             Show this help message

Environment:
  venvs are stored in .venv/ directories
  Search starts from cwd and traverses up to ~
  When outside ~, commands fall back to ~/.venv/""")
    return 0


# main()
# Entry point. Parses command-line arguments and dispatches to subcommand handlers.
#
# Returns:
#   Exit code from the subcommand handler
def main():
    parser = argparse.ArgumentParser(
        prog='vup-core',
        description='Python backend for vup virtual environment manager'
    )
    subparsers = parser.add_subparsers(dest='command', required=True)

    # find <name> [--start-dir <dir>] [--no-traverse]
    p_find = subparsers.add_parser('find', help='Find a venv by name')
    p_find.add_argument('name', help='Name of the venv to find')
    p_find.add_argument('--start-dir', default=None, help='Directory to start search from')
    p_find.add_argument('--no-traverse', action='store_true', help='Disable upward directory traversal')
    p_find.set_defaults(func=cmd_find)

    # ls [--start-dir <dir>]
    p_ls = subparsers.add_parser('ls', help='List all discoverable venvs')
    p_ls.add_argument('--start-dir', default=None, help='Directory to start listing from')
    p_ls.set_defaults(func=cmd_ls)

    # validate <path>
    p_validate = subparsers.add_parser('validate', help='Validate a venv path')
    p_validate.add_argument('path', help='Path to validate')
    p_validate.set_defaults(func=cmd_validate)

    # init
    p_init = subparsers.add_parser('init', help='Initialize .venv/ directory')
    p_init.set_defaults(func=cmd_init)

    # new <name>
    p_new = subparsers.add_parser('new', help='Create a new venv')
    p_new.add_argument('name', help='Name of the venv to create')
    p_new.set_defaults(func=cmd_new)

    # prompt <venv-path>
    p_prompt = subparsers.add_parser('prompt', help='Generate prompt identifier')
    p_prompt.add_argument('venv_path', help='Full path to the venv')
    p_prompt.set_defaults(func=cmd_prompt)

    # help
    p_help = subparsers.add_parser('help', help='Show user-facing help')
    p_help.set_defaults(func=cmd_help)

    args = parser.parse_args()
    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
